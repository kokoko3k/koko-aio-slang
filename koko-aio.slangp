

#    Koko-aio shader is meant to be an all-in one crt shader.
#    It can be configured with many parameters, so that can be
#    scaled to run on even on modest gpus while still developed to
#    run with heavier presets on at least Haswell+ iGpus.
#    It is not meant to simulate the internal behaviour of CRT displays,
#    but to give users the parameters to make their monitors to look similar.
#    Several presets are included.

#    Actually it provides emulation for:
#        scanlines, screenlines, RGB vertical masks, horizontal slot masks,
#        glowing, haloing, blooming, gamma and SATURATION correction,pixel_outi        
#        black frame insertions, interlace emulation, antialiasing.

#    External code by:
#    * Nvidia (FXAA)



    
# Bezel texture contains the following infomations:
#   - The red channel represents the luminance information
#   - The green channel represents the highlights
#   - The alpha channel in the inner frame represents the part of the bezel that will be filled by the game content
#   - The blue channel represents the part of the bezel that will be filled by the game reflection.


                textures = "monitor_body_curved;monitor_body_straight;bg_under;bg_over;backdrop"
                
            monitor_body_curved = "textures/monitor_body_curved.png"
     monitor_body_curved_linear = "true"
  # Does this work?
  monitor_body_curved_wrap_mode = "clamp_to_edge"
     monitor_body_curved_mipmap = "true"

            monitor_body_straight = "textures/monitor_body_straight.png"
     monitor_body_straight_linear = "true"
  # Does this work?
  monitor_body_straight_wrap_mode = "clamp_to_edge"
     monitor_body_straight_mipmap = "true"
     
                bg_under = "textures/background_under.png"
         bg_under_linear = "true"
      bg_under_wrap_mode = "mirrored_repeat"
         bg_under_mipmap = "true"
          
                 bg_over = "textures/background_over.png"
          bg_over_linear = "true"
       bg_over_wrap_mode = "mirrored_repeat"
          bg_over_mipmap = "true"

        #This is for support for arcade backdrop pictures, enable it in config.inc.
                backdrop = "textures/boothill.jpg"
         backdrop_linear = "true"
      backdrop_wrap_mode = "mirrored_repeat"
         backdrop_mipmap = "true"

shaders = 17

# NTSC Color artifacts pass:
# The very first pass emulates ntsc color artifacting.
# Being a fast single pass process, don't expect it to be 100% accurate
# It is able to drag rainbows as seen in Megadrive games with an option
# To make it oblique.
# It also does input colot corrections to the input signal (saturation,brightness,contrast...)
           shader0 = shaders/ntsc_pass.slang
            alias0 = "ntsc_pass"
    filter_linear0 = false
       scale_type0 = source
            scale0 = 1.0
        wrap_mode0 = "mirrored_repeat"


        
# This pass, wrongly named first pass, since we prepended the ntsc pass
# and emulates the flickering observed on crts when the input signal is interlaced
# and there is high brightness difference between adiacent scanlines.
# This pass is able to generate mipmaps because the next pass has mipmap_input true.
#
# Note that the wrap_mode is set to "mirrored_repeat".
# This allow to cheaply generate a mirrored image that will be used later on to
# draw reflections on the bezel.
#
# Also, it upscales the input signal to 2X.
# This is needed because FXAA, the glow and the halo pass works best at at least 640x480 resolution.
# Note that this is needed only for lowres content, but if the input signal is already at that
# size, there is no need to scale to 2x, and it is possible to gain performance by turning
# scale_x1 and scale_y1 from 2.0 to 1.0.
#
# A special note for P-UAE core (Commodore Amiga), is needed, because it outputs by default to
# 720 pixel width and about 280p; this means that for P-UAE you can use scale_x1 = 1.0
# and only scale_y1 = 2.0 is needed.
# As an alternative option you can configure P-UAE to always output to low resolution for x and y
# But this way you loose the emulation for hires content (not much games uses it anyway).
           shader1 = shaders/first_pass.slang
            alias1 = "first_pass"
    filter_linear1 = false
       scale_type1 = source
          scale_x1 = 2.0
          scale_y1 = 2.0  
        wrap_mode1 = "mirrored_repeat"



# Nvidia fxaa pass:
# works good for "SD" resolutions
# FXAA don't really need any mipmap, but since mipmaps from first_pass are needed by
# some subsequent passes, specify that FXAA_pass wants mipmaps
# makes first_pass mipmaps available to everyone.
# Even if theoretically not needed, texture() occurrence in FXAA_pass needed to be switched 
# to textureLod(..,0.0) or it acts weird, don't ask me why.
           shader2 = shaders/fxaa.slang
            alias2 = "FXAA_pass"
    filter_linear2 = true
       scale_type2 = source
            scale2 = 1.0
     mipmap_input2 = true
        wrap_mode2 = "clamp_to border"

        

# This pass emulates NTSC/PAL composite color bleeding and deconvergence
# deconvergence should really be applied in th final pass, but it is too heavy there.
# This pass also apply the input gamma needed for glow pass.
           shader3 = shaders/shift_and_bleed.slang
            alias3 = "shift_and_bleed_pass"
    filter_linear3 = true
            scale3 = 1.0
       scale_type3 = source
float_framebuffer3 = true
     mipmap_input3 = false
        wrap_mode3 = "mirrored_repeat"

        
        
# Blur and/or glows the image as requested 
# This passes aims to simulate the signal input power.
           shader4 = shaders/in_glow_x.slang
            alias4 = "in_glow_pass_x"
    filter_linear4 = true
            scale4 = 1.0
       scale_type4 = source    
float_framebuffer4 = true
        wrap_mode4 = "mirrored_repeat"
        
           shader5 = shaders/in_glow_y.slang
            alias5 = "in_glow_pass"
    filter_linear5 = true
            scale5 = 1.0
       scale_type5 = source    
float_framebuffer5 = true
        wrap_mode5 = "mirrored_repeat"
            
          
        
# This essentially is the same as glowing by a code point of view.
# But the result of this pass will be added (+) to the input signal
# in the final pass.
           shader6 = shaders/halo_x.slang
            alias6 = "halo_pass_x"
    filter_linear6 = true
            scale6 = 1.0
       scale_type6 = source
float_framebuffer6 = true
     mipmap_input6 = false
        wrap_mode6 = "clamp_to_edge"
        
           shader7 = shaders/halo_y.slang
            alias7 = "halo_pass"
    filter_linear7 = true
            scale7 = 1.0
       scale_type7 = source
float_framebuffer7 = true
     mipmap_input7 = false
        wrap_mode7 = "clamp_to_edge"



# Get the average luminance needed by ambilight here, because:
#   * mipmap_input only works on "Source" texture
#   * the following pass does not use the previous one 
#   * the previous pass represents scene changes.

#   The rgb channels of the following pass contains luminance info
#   Used by the bezel code to light up the bezel corners.
#   The alpha channel contains the sum/3.0 of rgb channels
#   used to detect scene changes.

# This pass computes the average luminance of the image
# by grabbing a mipmap from first_pass.
# It stores at:
# alpha@coords 0.25,0.25 at reduced sampling to aid ambient light scene change detection
# alpha@coords 0.75,0.75 temporally smoother for use with bloom exposure and dynamic zoom
# rgb: it puts a small mipmap from first_pass that will be used to light-up the bezel highlights
# alpha@other coords: simple continuous sampling used to modulate bezel highlights strength.
               shader8 = shaders/avglum_pass.slang
                alias8 = "avglum_pass"
        filter_linear8 = true
           scale_type8 = source
                scale8 = 0.5
            wrap_mode8 = "mirrored_repeat"
         mipmap_input8 = false

         
         
# The following passes will blur the mirrored part of first_pass
# to emulate soft bezel reflections.

               shader9 = shaders/reflection_blur_pre.slang
                alias9 = "reflected_blurred_pass_pre"
        filter_linear9 = true
           scale_type9 = source
                scale9 = 1.0
            wrap_mode9 = "clamp_to_border"

            
               shader10 = shaders/reflection_blur.slang
                alias10 = "reflected_blurred_pass"
        filter_linear10 = true
           scale_type10 = source
                scale10 = 1.0
         mipmap_input10 = true
            wrap_mode10 = "mirrored_repeat"

# In the following passes we emulate bloom effect.
# Since the radius has to be high, we sample first_pass
# and then do other blur passes at reduced size to keep it fast.
# Every blur pass samples radially around the center and offsets
# the starting point in every subsequent pass.
               shader11 = shaders/bloom_pass_1.slang
                alias11 = "bloom_pass_1"
        filter_linear11 = true
           scale_type11 = source
                scale11 = 1.0
            wrap_mode11 = "mirrored_repeat"
    
    
               shader12 = shaders/bloom_pass_2.slang
                alias12 = "bloom_pass_2"
        filter_linear12 = true
           scale_type12 = source
                scale12 = 0.5
            wrap_mode12 = "clamp_to_edge"

            
               shader13 = shaders/bloom_pass_3.slang
                alias13 = "bloom_pass_3"
        filter_linear13 = true
           scale_type13 = source
                scale13 = 1.0
            wrap_mode13 = "clamp_to_edge"

        
               shader14 = shaders/bloom_pass_4.slang
                alias14 = "bloom_pass_final"
        filter_linear14 = true
           scale_type14 = source
                scale14 = 1.0
            wrap_mode14 = "mirrored_repeat"
    float_framebuffer14 = "true"



# Gather mipmaps from first_pass and use them to light virtual leds under the virtual monitor 
# and temporally smooth led lights.
# Extra logic makes it possible to lower the led reaction time when a scene change is detected.
# this is achieved through average luminance sampling from avglum_pass
               shader15 = shaders/ambi_temporal_pass.slang
                alias15 = "ambi_temporal_pass"
        filter_linear15 = true
           scale_type15 = viewport
                scale15 = 0.05
            wrap_mode15 = "clamp_to_border"
    float_framebuffer15 = true
    

# This pass pass will do everything needed to happen at screen coordinates:
# * The composition of the previous passes with the bloomed image, 
# * vignette and spot light
# * Scanlines
# * Phosphors masks 
# * Black frame insertions
# * Bezel
# * Background images
           shader16 = shaders/final_pass.slang
            alias16 = "final_pass"
    filter_linear16 = true
       scale_type16 = viewport
            scale16 = 1.0
        wrap_mode16 = "mirrored_repeat"
        




        
# TODO:
#    [v] Guess more aspect ratios:
#			nope: Guessing is impossible..
#    [v] Use gauss blur for composite color bleeding?
#    	    Tried, does not produce great visible improvements
#    [v] Vignette and spot could be done earlier at lower res?
#        Made a bit lighter version right in final_pass instead.
#    [v] reference new repo from the main one
#    [v] Noise is not visible on black or white, much more on gray, why?
#        Probably a matter of post processing
#    [v] Try to get rid of mark_unneeded() in reflection_blur_y
#        didit and it is useless, no measurable perf increase.
#    [v] Why tv presets have +5% brightness?
#        Because the contrast is pushed too.
#    [v] First bloom pass: why don't we use an higher lod?
#        Using an higher lod makes the bloom less prone to detect thinner lines
#        So, no.
#    [v] Does bloom quality improve if we sample from original?
#        yeah!
#    [v] #pragmas to vertex shader to fragment shader
#        Why and when performances start to degrade?
#        ...It seems it happen when too many UBOs or Push constants are readed
#           by the Vertex shader and passed to the fragment one.
#           (not tested if the pass from fragment to vertex is needed to reproduce the issue)
#    [v] What if i do vmask and darklines (scanlines too in alpha??)
#        in a little pass that scales to absolute size?
#        or even a lut with the mask...
#        No gain, texture lookups are heavier than expected.
#    [v] textureSize() appears to be quite heavy, consider to make bezel coords fixed.
#        Done, expected to gain more, if something.
#        You just use it to calc lods, is it worth?
#    [v] Reflection blur size, make id not dependand on input resolution.
#    [v] When colorizing bezel with ambilight, apply noise over it as well
#    [v] Blur less near the start of the bezel
#    [v] Make the reflection blur shade point configurable
#    [v] Rotate image: auto (-1)... Does it work?
#        yes.
#    [v] Put blank lines after #pragma parameter groups
#    [v] Bloom: would it make sense to gather the average luminosity in a wide
#        zone around the current pixel instead of the whole scene?
#        Yes, it works good.
#    [v] should min_w in avglum_pass depend on content resolution?
#        lod = log2(params.SourceSize.y / min_w); in avglum_pass is wrong (w/y?)
#        Both fixed by specifying the lod instead of doing stupid calculations.mip_lod
#        So fixed, and achieved what was needed.
#    [v] When using dynamic zoom, bezel reflection should be dynamically adapted
#        ...this is tough, zomoing reflection wouldn't work.
#    [v] Further tune reflection shade
#    [v] Do a debug image with a white object on black backgroud to tune bloom exposure over time
#    [v] Unbranch phase shift in ntsc pass, trivial
#    [v] Negative gap brightness produces glitches on bezel (nvidia specific?)
#        yes, due to negative pow base.         
#    [v] Unrolled blur in relfections is not gaussiany(gaussianx), was that a mistake?
#        No mistake, they look best that way since we need big blurs.
#    [v] When colorizing the bezel via ambilight, a small area between the tube and the
#        bezel border is colored and should not.
#    [.] Darkline, vmask: whiteness can be pre-calculated outside.
#        Half done, gained something.
#    [v] reflection blur: can we make better use of mipmaps instead of blindly use lod = 2.0?
#    [v] avglum_pass needs to react to content aspect override
#    [ ] check branching conditions in first_pass.slang
#    [ ] Better debanding?
#    [ ] Should the flickering be aware of the scanline?
#        read: does a scanline dark gap increment the flickering or not?
#    [ ] deconvergence after glow/halo?
#    [ ] Glow spread in final pass?
#    [ ] Find a way to smooth borders without cropping the image
#    [ ] Allow to configure new bezel parameters?
#        Reflection strength, corner shape, size and fade?  
#    [ ] Allow to set a different aspect for content
#        (which could be translated to a different aspect for bezel, maybe simpler)
#        Problem is reflection alignment.
#    [ ] Ambi temporal pass, move content override code to vertex shader
#    [..] Bezel colorization via ambilight acts strangely when the content aspect is shrinked
#          [  ] It also bleeds over alpha channel in the internal frame.
#          [  ] disabled by now till we find a better way to handle it.
#               This: https://github.com/kokoko3k/koko-aio-slang/commit/1fbbee4f73948cd85e0d53db3a2d4eaab8951a8f is a reference commit
#               where i switched from a try to a second one.
#          [  ] maybe it can be modulated from the outside via min(coord.x,coord.y)
#    [ ] bloom should bleed over when forcing geometry aspect
#    [ ] reflection blurriness should not depend on input resolution
#    [ ] specular reflections does not 100% follow the image when overriding aspect
#    [ ] copy base presets to overlay shader
#    [ ] Ambient light skip coords ahould be aware of the h/v shift override or black box whould appear
#        (check local preset: testambishift)        
